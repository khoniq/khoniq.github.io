<h1>Xlibで遊んでみる4</h1>
<time>2023-01-02</time>

<p>
前回: <a href="xlib_playground3.html">Xlibで遊んでみる3</a>
</p>
<p>
言語: C言語<br />
ソースコード: \
<a href="https://git.mtkn.jp/xlib_playground">git</a>
</p>

<h2>衝突判定とその処理</h2>
<p>
これまでは一つの四角形だけを描画していたが、今回は複数の四角形を作成\
して動かしてみた。ランダムな場所にランダムな運動量で動かして、\
他のものやウィンドウの縁とぶつかったら跳ね返るようにした。\
</p>
<p>
回転しない四角形どうしの衝突判定は簡単である。x軸方向とy軸方向の\
両方に重なりがあれば衝突している:
</p>
<pre><code>\
struct square {
	float ppx, ppy; // previous position
	float px, py;   // current position
	float vx, vy;   // velocity
	int w, h;       // width and height
};

int
test_collision(struct square *s1, struct square* s2)
{
	return s1-&gt;px &lt; s2-&gt;px + s2-&gt;w && s2-&gt;px &lt; s1-&gt;px + s1-&gt;w &&
	       s2-&gt;py &lt; s1-&gt;py + s1-&gt;h && s1-&gt;py &lt; s2-&gt;py + s2-&gt;h;
}
</code></pre>

<p>
衝突後の処理は多少めんどくさかった。\
衝突した時は既にめりこんでいるので、まずはそれぞれをめりこんだ距離の半分\
ずつずらして衝突を解消するようにした。この際、x軸方向にぶつかったのか、\
y軸方向にぶつかったのかで、それぞれの軸方向にひっぺがすようにしている。\
二つの四角形の各軸に関するめりこんだ距離<code>lapx</code>、<code>lapy</code>\
と各軸に関する相対速度<code>rel_vx</code>、<code>rel_vy</code>の比を比べれば\
どちらの軸方向にぶつかったかが分かるはずである、多分 :
</p>
<pre><code>\
void
handle_collision_mm(struct square *s1, struct square *s2)
{
	if (!test_collision(s1, s2))
		return;

	float lapx = min(s1-&gt;px + s1-&gt;w, s2-&gt;px + s2-&gt;w) - max(s1-&gt;px, s2-&gt;px);
	float lapy = min(s1-&gt;py + s1-&gt;h, s2-&gt;py + s2-&gt;h) - max(s1-&gt;py, s2-&gt;py);
	float rel_vx = max(s1-&gt;vx - s2-&gt;vx, s2-&gt;vx - s1-&gt;vx);
	float rel_vy = max(s1-&gt;vy - s2-&gt;vy, s2-&gt;vy - s1-&gt;vy);

	if (lapx / rel_vx &lt; lapy / rel_vy) {
		if (s1-&gt;px + s1-&gt;w &lt; s2-&gt;px + s2-&gt;w / 2) {
			s1-&gt;px -= lapx / 2;
			s2-&gt;px += lapx / 2;
		} else {
			s1-&gt;px += lapx / 2;
			s2-&gt;px -= lapx / 2;
		}
	} else {
		if (s1-&gt;py + s1-&gt;h &lt; s2-&gt;py + s2-&gt;h / 2) {
			s1-&gt;py -= lapy / 2;
			s2-&gt;py += lapy / 2;
		} else {
			s1-&gt;py += lapy / 2;
			s2-&gt;py -= lapy / 2;
		}
	}
}
</code></pre>
<p>
衝突は弾性衝突として、衝突したそれぞれの四角形の速度を\
更新した。質量は四角形の面積として計算している。\
衝突後の速度はエネルギー保存則と運動量保存則から導いたのでしんどかった。
</p>
<pre><code>\
void
handle_collision_elastic(struct square *s1, struct square *s2)
{
	if(!test_collision(s1, s2))
		return;

	float v1, v2;
	float m1 = s1-&gt;w * s1-&gt;h;
	float m2 = s2-&gt;w * s2-&gt;h;

	float lapx = min(s1-&gt;px + s1-&gt;w, s2-&gt;px + s2-&gt;w) - max(s1-&gt;px, s2-&gt;px);
	float lapy = min(s1-&gt;py + s1-&gt;h, s2-&gt;py + s2-&gt;h) - max(s1-&gt;py, s2-&gt;py);

	if (lapx &lt; lapy) {
		v1 = s1-&gt;vx;
		v2 = s2-&gt;vx;
		s1-&gt;vx = 2*m2/(m1+m2)*v2 + (m1-m2)/(m1+m2)*v1;
		s2-&gt;vx = 2*m1/(m1+m2)*v1 + (m2-m1)/(m1+m2)*v2;
	} else {
		v1 = s1-&gt;vy;
		v2 = s2-&gt;vy;
		s1-&gt;vy = 2*m2/(m1+m2)*v2 + (m1-m2)/(m1+m2)*v1;
		s2-&gt;vy = 2*m1/(m1+m2)*v1 + (m2-m1)/(m1+m2)*v2;
	}

	handle_collision_mm(s1, s2);
}
</code></pre>

<h2>サブティック</h2>
<p>
この名前が適切かどうか分からないが、前のフレームから次のフレームまで\
の時間をさらに何等分かして衝突判定の制度を上げた（マクロは括弧でかこって\
分かりにくいバグを防げとどこかに書いていたのでそうすることにした）:
</p>
<pre><code>\
#define SUB_TIC (4)

void
game_play(void)
{
	/* ... */
	while (next_menu == GAME_PLAY) {
		/* ... */
		for (int j = 0; j &lt; SUB_TICK; j++) {
			for (int i = 0; i &lt; NUM_SQUARE; i++)
				next_tick(&square[i], 1000 * 1000 * 1000 / FPS / SUB_TICK);

			for (int i = 0; i &lt; NUM_SQUARE; i++)
				for (int j = i + 1; j &lt; NUM_SQUARE; j++) {
					handle_collision_elastic(&square[i], &square[j]);
					/* ... */
				}
			/* ... */
		}
		/* ... */
	}
	/* ... */
}
</code></pre>

<h2>完成品</h2>
<p>
<a href="https://git.mtkn.jp/xlib_playground/file/ex4/ex4.c.html">git</a>
</p>
<p>
<video controls>
<source src="videos/ex4.webm" type="video/webm">
</video>
</p>

<h2>参考</h2>
<ul>
<li><a href="https://tronche.com/gui/x/xlib/">The Xlib Manual(html conversion)</a></li>
</ul>
<p>
次の記事: \
<a href="xlib_playground5.html">Xlibで遊んでみる5</a>
</p>
